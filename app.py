# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vMLiexVf2jHKPx1DHWwe28naJjiF9Tb6
"""

from flask import Flask, render_template, request, jsonify
import pandas as pd
import requests
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder

medals_data = pd.read_csv('medals.csv')

print("Medals Data:-\n")
print(medals_data.isnull().sum())

medals_data.drop('participant_title', inplace=True, axis=1)
medals_data.drop('country_code', inplace=True, axis=1)
medals_data.drop('athlete_url', inplace=True, axis=1)
print(medals_data.isnull().sum())

medals_data.dropna(inplace = True)

print(medals_data.isnull().sum())

print(medals_data)

enc = LabelEncoder()

# Converting alphanumeric to numeric for training data
medals_data['discipline_title'] = enc.fit_transform(medals_data['discipline_title'])
medals_data['slug_game'] = enc.fit_transform(medals_data['slug_game'])
medals_data['event_title'] = enc.fit_transform(medals_data['event_title'])
medals_data['event_gender'] = enc.fit_transform(medals_data['event_gender'])
medals_data['medal_type'] = enc.fit_transform(medals_data['medal_type'])
medals_data['participant_type'] = enc.fit_transform(medals_data['participant_type'])
medals_data['athlete_full_name'] = enc.fit_transform(medals_data['athlete_full_name'])
medals_data['country_name'] = enc.fit_transform(medals_data['country_name'])
medals_data['country_3_letter_code'] = enc.fit_transform(medals_data['country_3_letter_code'])

print(medals_data)

# app.py

app = Flask(__name__)

# Constants for API integration (Replace with real API details)
API_BASE_URL = 'https://api.olympic-games.com/'
SCHEDULE_ENDPOINT = 'schedule/'
MEDAL_PREDICTION_ENDPOINT = 'medal-prediction/'




# Load and preprocess the provided dataset
df = pd.get_dummies(medals_data, columns=['discipline_title', 'event_title', 'country_name'])

# Prepare data for training the machine learning model
X = df.drop('medal_type', axis=1)
y = df['medal_type']
model = RandomForestClassifier(random_state=42)
model.fit(X, y)




# Helper functions for API integration
# Sample schedule data (Replace with actual API response)
dummy_schedule_data = [
    {
        "event_id": 1,
        "event_title": "Swimming - Men's 100m Freestyle",
        "event_date": "2023-07-28",
        "event_time": "10:00:00",
        "venue": "Aquatics Center",
        "location": "Tokyo, Japan"
    },
    {
        "event_id": 2,
        "event_title": "Athletics - Women's 400m Final",
        "event_date": "2023-07-28",
        "event_time": "18:30:00",
        "venue": "Olympic Stadium",
        "location": "Tokyo, Japan"
    },
    {
        "event_id": 3,
        "event_title": "Basketball - Men's Semifinal",
        "event_date": "2023-07-29",
        "event_time": "14:00:00",
        "venue": "Saitama Super Arena",
        "location": "Saitama, Japan"
    },
    # Add more events here
]

def fetch_schedule():
    # Replace this dummy data with actual API request and response handling
    return dummy_schedule_data

'''
def fetch_schedule():
    try:
        response = requests.get(API_BASE_URL + SCHEDULE_ENDPOINT)
        if response.status_code == 200:
            schedule_data = response.json()
            return schedule_data
    except requests.RequestException as e:
        print(f"Error fetching schedule: {e}")
    return None

    ---------------As we were not able to get an API for live schedule we used dummy data
            but the proper code for a live API is in this docstring---------------
'''





# Sample dataset (Replace with the actual dataset)

df = medals_data

def fetch_medal_prediction(event_id):
    # Filter the dataset for the given event_id
    event_data = df[df['event_id'] == event_id]

    if event_data.empty:
        return None

    # Group the data by country and count the number of each medal type (Gold, Silver, Bronze)
    medal_counts = event_data['medal_type'].value_counts()

    # Get the most common medal (Gold, if tied, take the first one)
    most_common_medal = medal_counts.idxmax()

    # Get the country/countries with the most common medal
    predicted_countries = list(event_data[event_data['medal_type'] == most_common_medal]['country_name'].unique())

    # Prepare the medal prediction data
    medal_prediction_data = {
        "event_id": event_id,
        "event_title": event_data['event_title'].iloc[0],  # Assume the event title is the same for all rows of the event
        "medal": most_common_medal,
        "predicted_countries": predicted_countries
    }

    return medal_prediction_data





# Flask routes for different app sections
@app.route('/')
def home():
    return render_template('index.html')

@app.route('/schedule')
def schedule():
    schedule_data = fetch_schedule()
    return render_template('schedule.html', schedule_data=schedule_data)

@app.route('/predict_medal', methods=['POST'])
def predict_medal():
    if request.method == 'POST':
        event_id = request.form['event_id']
        medal_prediction = fetch_medal_prediction(event_id)
        return render_template('medal_prediction.html', medal_prediction=medal_prediction)





# Sample dataset (Replace with the actual dataset)
df = medals_data

@app.route('/data_insights')
def data_insights():
    # Calculate the total number of medals won by each country
    country_medal_counts = df.groupby('country_name')['medal_type'].value_counts().unstack().fillna(0)

    # Calculate the total number of medals won by each participant
    participant_medal_counts = df.groupby('athlete_full_name')['medal_type'].value_counts().unstack().fillna(0)

    # Get the most successful country (highest total medals)
    most_successful_country = country_medal_counts.sum(axis=1).idxmax()

    # Get the top-performing athlete (highest total medals)
    top_performing_athlete = participant_medal_counts.sum(axis=1).idxmax()

    # Prepare the data insights
    data_insights = {
        "most_successful_country": most_successful_country,
        "top_performing_athlete": top_performing_athlete,
        "country_medal_counts": country_medal_counts.to_dict(),
        "participant_medal_counts": participant_medal_counts.to_dict(),
    }

    return render_template('data_insights.html', data_insights=data_insights)



if __name__ == '__main__':
    app.run(debug=True)